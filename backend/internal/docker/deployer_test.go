package docker

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"omar-kada/autonas/internal/events"
	"omar-kada/autonas/internal/files"
	"omar-kada/autonas/internal/storage"
	"omar-kada/autonas/models"
	"omar-kada/autonas/testutil"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type Mocker struct {
	mock.Mock
}

func (m *Mocker) WriteToFile(filePath string, content string) error {
	args := m.Called(filePath, content)
	return args.Error(0)
}

func (m *Mocker) Exec(cmd string, cmdArgs ...string) ([]byte, error) {
	args := m.Called(cmd, cmdArgs)
	return args.Get(0).([]byte), args.Error(1)
}

func (m *Mocker) Copy(src, dest string) error {
	args := m.Called(src, dest)
	return args.Error(0)
}

func newDeployerWithMocks(mocker *Mocker) *deployer {
	db := testutil.NewMemoryStorage()
	depStore, _ := storage.NewDeploymentStorage(db)
	dep, _ := depStore.InitDeployment("test commit", "Test", "", []models.FileDiff{})
	ctx := events.GetDeploymentContext(context.Background(), dep)

	return &deployer{
		dispatcher:  events.NewVoidDispatcher(),
		cmdExecuter: mocker,
		copier:      mocker,
		envGenerator: &EnvGenerator{
			writer: mocker,
		},
		ctx: ctx,
	}
}

var mockConfig = models.Config{
	Environment: models.Environment{
		"AUTONAS_HOST": "localhost",
	},
	Services: map[string]models.ServiceConfig{
		"svc1": {
			"Port": "8080",
		},
	},
}

func TestDeployServices_SingleService_WithOverride(t *testing.T) {
	mocker := &Mocker{}
	deployer := newDeployerWithMocks(mocker)

	baseDir := t.TempDir()
	serviceDir := filepath.Join(baseDir, "svc1")
	envFilePath := filepath.Join(serviceDir, ".env")
	err := os.Mkdir(serviceDir, 0o750)
	assert.NoError(t, err)

	err = files.NewWriter().WriteToFile(
		envFilePath,
		"CUSTOM_VAR=will not be overridden\n\n"+
			"PORT=80",
	)

	assert.NoError(t, err)

	wantEnv := strings.Join([]string{
		"CUSTOM_VAR=will not be overridden",
		"",
		"# PORT=80 # Overridden by AutoNAS ",
		"# The next values are generated by AutoNAS : ",
		"AUTONAS_HOST=localhost",
		"PORT=8080",
	}, "\n") + "\n"
	mock.InOrder(
		mocker.On("Copy", "repo/services/svc1", serviceDir).Return(nil),
		mocker.On("WriteToFile", envFilePath, wantEnv).Return(nil),
		mocker.On(
			"Exec", "docker", []string{"compose", "--project-directory", filepath.Join(baseDir, "svc1"), "up", "-d"},
		).Return([]byte{}, nil),
	)
	errs := deployer.DeployServices(mockConfig, models.DeploymentParams{
		ServicesDir: baseDir,
	})
	assert.Len(t, errs, 0)
}

func TestRemoveServices_MultipleServices(t *testing.T) {
	mocker := &Mocker{}
	baseDir := t.TempDir()
	err := os.Mkdir(filepath.Join(baseDir, "svc1"), 0o750)
	assert.NoError(t, err)
	err = os.Mkdir(filepath.Join(baseDir, "svc2"), 0o750)
	assert.NoError(t, err)

	deployer := newDeployerWithMocks(mocker)
	mocker.On(
		"Exec", "docker", []string{"compose", "--project-directory", filepath.Join(baseDir, "svc1"), "down"},
	).Return([]byte{}, nil)
	mocker.On(
		"Exec", "docker", []string{"compose", "--project-directory", filepath.Join(baseDir, "svc2"), "down"},
	).Return([]byte{}, fmt.Errorf("mock error"))
	errs := deployer.RemoveServices([]string{"svc1", "svc2"}, baseDir)

	assert.Len(t, errs, 1)
	assert.ErrorContains(t, errs["svc2"], "mock error")
}

type ExpectedErrors struct {
	writeFileErr error
	runCmdErr    error
}

var (
	ErrWriteFile = errors.New("writeFile error")
	ErrRunCmd    = errors.New("runCmd error")
	ErrCopy      = errors.New("copyServices error")
	ErrGenerate  = errors.New("generate file error")
	ErrFetch     = errors.New("sync config error")
)

func TestDeployServices_Errors(t *testing.T) {
	testCases := []struct {
		name          string
		errors        ExpectedErrors
		expectedError error
	}{
		{
			name:          "writeFile error",
			errors:        ExpectedErrors{writeFileErr: ErrWriteFile},
			expectedError: ErrWriteFile,
		},
		{
			name:          "runCmd error",
			errors:        ExpectedErrors{runCmdErr: ErrRunCmd},
			expectedError: ErrRunCmd,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			mocker := &Mocker{}
			deployer := newDeployerWithMocks(mocker)
			mocker.On("Copy", mock.Anything, mock.Anything).Return(tc.errors.writeFileErr)
			mocker.On("WriteToFile", mock.Anything, mock.Anything).Return(tc.errors.writeFileErr)
			mocker.On("Exec", "docker", mock.Anything).Return([]byte{}, tc.errors.runCmdErr)
			errs := deployer.DeployServices(mockConfig, models.DeploymentParams{
				ServicesDir: "/services",
			})
			// TODO : add tests for aggregared errors
			assert.Len(t, errs, 1)
			assert.ErrorIs(t, errs["svc1"], tc.expectedError)
		})
	}
}

func TestRemoveAndDeployStacks_Success(t *testing.T) {
	mocker := &Mocker{}
	deployer := newDeployerWithMocks(mocker)

	mock.InOrder(
		mocker.On(
			"Copy", "configDir/repo/services/svc1", "/services/svc1",
		).Return(nil),
		mocker.On("WriteToFile", mock.Anything, mock.Anything).Return(nil),
		mocker.On(
			"Exec", "docker", []string{"compose", "--project-directory", filepath.Join("/", "services", "svc1"), "up", "-d"},
		).Return([]byte{}, nil),
	)

	err := deployer.RemoveAndDeployStacks(mockConfig, mockConfig, models.DeploymentParams{
		ServicesDir: "/services",
		WorkingDir:  "configDir",
	})
	assert.NoError(t, err)
}

func TestRemoveAndDeployStacks_Errors(t *testing.T) {
	type ExpectedErrors struct {
		copyErr  error
		writeErr error
		runErr   error
	}
	testCases := []struct {
		name          string
		errors        ExpectedErrors
		expectedError error
	}{
		{
			name:          "run error",
			errors:        ExpectedErrors{runErr: ErrRunCmd},
			expectedError: ErrRunCmd,
		},

		{
			name:          "copyServices error",
			errors:        ExpectedErrors{copyErr: ErrCopy},
			expectedError: ErrCopy,
		},

		{
			name:          "write to file error",
			errors:        ExpectedErrors{writeErr: ErrWriteFile},
			expectedError: ErrWriteFile,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			mocker := &Mocker{}
			deployer := newDeployerWithMocks(mocker)
			mock.InOrder(
				mocker.On("WriteToFile", mock.Anything, mock.Anything).Return(tc.errors.writeErr),
				mocker.On(
					"Exec", "docker", []string{"compose", "--project-directory", filepath.Join("/", "services", "svc1"), "up", "-d"},
				).Return([]byte{}, tc.errors.runErr),
			)

			mocker.On(
				"Copy", "configDir/repo/services/svc1", "/services/svc1",
			).Return(tc.errors.copyErr)

			mocker.On(
				"Copy", "configDir/repo/services/svc3", "/services/svc3",
			).Return(tc.errors.copyErr)
			err := deployer.RemoveAndDeployStacks(mockConfig, mockConfig, models.DeploymentParams{
				ServicesDir: "/services",
				WorkingDir:  "configDir",
			})

			assert.ErrorContains(t, err, fmt.Sprint(tc.expectedError))
		})
	}
}
