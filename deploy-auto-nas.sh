#!/usr/bin/env bash
set -euo pipefail

declare -gA GLOBAL_VARS      # Associative array for global variables
declare -gA SERVICE_VARS     # Associative array for service-specific variables
declare -ga SERVICES_LIST    # Array for list of services

parse_ini_config() {
  local config_file="$1"
  
  local current_section=""     # Tracks the current section in the INI file
  echo "ðŸ” Parsing config file: $config_file"
  # Read the config file line by line
  while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line%%#*}" # Remove comments (everything after #)
    line="$(echo "$line" | xargs)" # Trim leading/trailing whitespace only
    [[ -z "$line" ]] && continue # Skip empty lines
    # Check for section header, e.g. [global] or [service]
    if [[ "$line" =~ ^\[(.*)\]$ ]]; then
      current_section="${BASH_REMATCH[1]}" # Set current section
      echo "  âž¡ Section: [$current_section]"
    # Check for key=value pairs
    elif [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
      key="${BASH_REMATCH[1]}"   # Extract key
      value="${BASH_REMATCH[2]}" # Extract value
      if [[ -z "$key" || -z "$value" ]]; then
        echo "âš ï¸ Malformed config line: $line" >&2
        continue
      fi
      if [[ "$current_section" == "global" ]]; then
        GLOBAL_VARS[$key]="$value" # Store in global vars
        # If key is SERVICES, split value into array
        if [[ "$key" == "SERVICES" ]]; then
          IFS=',' read -ra SERVICES_LIST <<< "$value"
          # Remove spaces from each service name
          for i in "${!SERVICES_LIST[@]}"; do
            SERVICES_LIST[$i]="$(echo "${SERVICES_LIST[$i]}" | xargs)"
          done
        fi
      elif [[ -n "$current_section" ]]; then
        # Store service-specific variable with section prefix
        SERVICE_VARS["$current_section|$key"]="$value"
      fi
    fi
  done < "$config_file"
}



# Make paths relative to the script location
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEFAULT_CONFIG="$SCRIPT_DIR/config.default.env"
CUSTOM_CONFIG="$SCRIPT_DIR/config.env"


if [[ -f "$DEFAULT_CONFIG" ]]; then
  parse_ini_config "$DEFAULT_CONFIG"
else
  echo "âš ï¸  Default config file not found: $DEFAULT_CONFIG"
fi
if [[ -f "$CUSTOM_CONFIG" ]]; then
  parse_ini_config "$CUSTOM_CONFIG"
else
  echo "âš ï¸  Custom config file not found: $CUSTOM_CONFIG"
fi


# Set global vars safely (avoid unbound variable errors)
PULL="${GLOBAL_VARS[PULL]:-0}"
BRANCH="${GLOBAL_VARS[BRANCH]:-main}"
STOP="${GLOBAL_VARS[STOP]:-0}"

SERVICES_PATH="${GLOBAL_VARS[SERVICES_PATH]:-}"
HOST="${GLOBAL_VARS[HOST]:-}"
DATA_PATH="${GLOBAL_VARS[DATA_PATH]:-}"

if [[ -z "$DATA_PATH" ]]; then
  echo "âŒ  DATA_PATH must be defined" >&2
  exit 1
fi

cd "$SCRIPT_DIR"

if [[ $PULL == 0 ]]; then
    echo "âš ï¸  PULL variable is not set or 0, pulling skipped!"
else
    echo "Checking out branch $BRANCH..."
    git fetch || { echo "Failed to fetch branches"; exit 1; }
    git checkout "$BRANCH" || { echo "Failed to checkout branch $BRANCH"; exit 1; }
fi

if [[ $STOP == 1 ]]; then

  echo "â¸ï¸  Stopping all containers managed by autonas"
  docker ps -q --filter "label=com.autonas.managed=true" | xargs -r docker stop

fi


# Copy source files to target directory
mkdir -p "$SERVICES_PATH"
echo "ðŸ“‚  Copying source files from $SCRIPT_DIR to $SERVICES_PATH"
cp -r "$SCRIPT_DIR/"* "$SERVICES_PATH/"


mkdir -p "$DATA_PATH"

# Ensure homepage config folder exists
mkdir -p "$SERVICES_PATH/services/homepage/config"

# Prepare YAML file
yaml_file="$SERVICES_PATH/services/homepage/config/services.yaml"
echo "- Services:" > "$yaml_file"


# Loop through services only if SERVICES_LIST is non-empty
if [[ ${#SERVICES_LIST[@]} -eq 0 ]]; then
  echo "âš ï¸  No services defined in config. Nothing to deploy."
else
  for service in "${SERVICES_LIST[@]}"; do
    echo "Deploying $service..."
    mkdir -p "$DATA_PATH/$service"


    env_file_path="$SERVICES_PATH/services/$service/.env"
    echo "# Generated by deploy-auto-nas.sh" > "$env_file_path"
    # Add global variables first
    #for gk in "${!GLOBAL_VARS[@]}"; do
    #  gval="${GLOBAL_VARS[$gk]}"
    #  echo "$gk=$gval" >> "$env_file_path"
    #done
    # Add service-specific variables
    for k in "${!SERVICE_VARS[@]}"; do
      if [[ "$k" == "$service|"* ]]; then
        env_key="${k#*|}"
        env_val="${SERVICE_VARS[$k]}"
        echo "$env_key=$env_val" >> "$env_file_path"
      fi
    done
    echo "DATA_PATH=$DATA_PATH/$service" >> "$env_file_path"
    echo "HOST=$HOST" >> "$env_file_path"
    echo "SERVICES_PATH=$SERVICES_PATH" >> "$env_file_path"

    # Add entry to services.yaml
    service_name="${service^}"
    port_val="${SERVICE_VARS[$service|PORT]:-80}"
    description_val="${SERVICE_VARS[$service|DESCRIPTION]:-$service_name}"
    icon_val="${SERVICE_VARS[$service|ICON]:-$service}"

    cat >> "$yaml_file" <<EOF
    - $service_name:
        href: http://$HOST:$port_val/
        description: $description_val
        icon: ${icon_val}.png
EOF

    # Run docker compose with env
    cd "$SERVICES_PATH/services/$service"
    docker compose up -d 
  done
fi

echo "âœ… Deployment finished. Homepage configuration YAML generated at $yaml_file"