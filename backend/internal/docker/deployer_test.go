package docker

import (
	"context"
	"errors"
	"fmt"
	"omar-kada/autonas/internal/events"
	"omar-kada/autonas/internal/files"
	"omar-kada/autonas/internal/storage"
	"omar-kada/autonas/models"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

type Mocker struct {
	mock.Mock
}

func (m *Mocker) WriteToFile(filePath string, content string) error {
	args := m.Called(filePath, content)
	return args.Error(0)
}

func (m *Mocker) Run(cmd string, cmdArgs ...string) error {
	args := m.Called(cmd, cmdArgs)
	return args.Error(0)
}

func (m *Mocker) Copy(src, dest string) error {
	args := m.Called(src, dest)
	return args.Error(0)
}

func (m *Mocker) CopyWithAddPerm(src, dst string, permission os.FileMode) error {
	args := m.Called(src, dst, permission)
	return args.Error(0)
}

func newManagerWithMocks(mocker *Mocker) *Deployer {
	store := storage.NewMemoryStorage()
	dep, _ := store.InitDeployment("test", "")
	ctx := context.WithValue(context.Background(), events.ObjectID, dep.Id)
	return &Deployer{
		dispatcher: events.NewDefaultDispatcher(store),
		cmdRunner:  mocker,
		copier:     mocker,
		envGenerator: &EnvGenerator{
			writer: mocker,
		},
		ctx: ctx,
	}
}

var mockConfig = models.Config{
	Extra: map[string]any{
		"AUTONAS_HOST": "localhost",
	},
	Services: map[string]models.ServiceConfig{
		"svc1": {
			//Extra: map[string]any{
			"Port": "8080",
			//},
		},
	},
}

func TestDeployServices_SingleService_WithOverride(t *testing.T) {
	mocker := &Mocker{}
	manager := newManagerWithMocks(mocker)

	baseDir := t.TempDir()
	envFilePath := filepath.Join(baseDir, "svc1", ".env")
	err := os.Mkdir(filepath.Join(baseDir, "svc1"), 0750)
	assert.NoError(t, err)

	err = files.NewWriter().WriteToFile(
		envFilePath,
		"CUSTOM_VAR=will not be overridden\n\n"+
			"PORT=80",
	)

	assert.NoError(t, err)

	wantEnv := strings.Join([]string{
		"CUSTOM_VAR=will not be overridden",
		"",
		"# PORT=80 # Overridden by AutoNAS ",
		"# The next values are generated by AutoNAS : ",
		"AUTONAS_HOST=localhost",
		"PORT=8080",
	}, "\n") + "\n"
	mock.InOrder(
		mocker.On("WriteToFile", envFilePath, wantEnv).Return(nil),
		mocker.On(
			"Run", "docker", []string{"compose", "--project-directory", filepath.Join(baseDir, "svc1"), "up", "-d"},
		).Return(nil),
	)
	errs := manager.DeployServices(mockConfig, baseDir)
	assert.Len(t, errs, 0)
}

func TestRemoveServices_MultipleServices(t *testing.T) {
	mocker := &Mocker{}
	baseDir := t.TempDir()

	manager := newManagerWithMocks(mocker)
	mocker.On(
		"Run", "docker", []string{"compose", "--project-directory", filepath.Join(baseDir, "svc1"), "down"},
	).Return(nil)
	mocker.On(
		"Run", "docker", []string{"compose", "--project-directory", filepath.Join(baseDir, "svc2"), "down"},
	).Return(fmt.Errorf("mock error"))
	errs := manager.RemoveServices([]string{"svc1", "svc2"}, baseDir)

	assert.Len(t, errs, 1)
	assert.ErrorContains(t, errs["svc2"], "mock error")
}

type ExpectedErrors struct {
	writeFileErr error
	runCmdErr    error
}

var (
	ErrWriteFile = errors.New("writeFile error")
	ErrRunCmd    = errors.New("runCmd error")
	ErrCopy      = errors.New("copyServices error")
	ErrGenerate  = errors.New("generate file error")
	ErrFetch     = errors.New("sync config error")
)

func TestDeployServices_Errors(t *testing.T) {
	testCases := []struct {
		name          string
		errors        ExpectedErrors
		expectedError error
	}{
		{
			name:          "writeFile error",
			errors:        ExpectedErrors{writeFileErr: ErrWriteFile},
			expectedError: ErrWriteFile,
		},
		{
			name:          "runCmd error",
			errors:        ExpectedErrors{runCmdErr: ErrRunCmd},
			expectedError: ErrRunCmd,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			mocker := &Mocker{}
			manager := newManagerWithMocks(mocker)
			mocker.On("WriteToFile", mock.Anything, mock.Anything).Return(tc.errors.writeFileErr)
			mocker.On("Run", "docker", mock.Anything).Return(tc.errors.runCmdErr)
			errs := manager.DeployServices(mockConfig, "/services")
			// TODO : add tests for aggregared errors
			assert.Len(t, errs, 1)
			assert.ErrorIs(t, errs["svc1"], tc.expectedError)
		})
	}
}

func TestRemoveAndDeployStacks_Success(t *testing.T) {
	mocker := &Mocker{}
	manager := newManagerWithMocks(mocker)

	mock.InOrder(
		mocker.On("WriteToFile", mock.Anything, mock.Anything).Return(nil),
		mocker.On(
			"Run", "docker", []string{"compose", "--project-directory", filepath.Join("/", "services", "svc1"), "up", "-d"},
		).Return(nil),
	)
	mocker.On(
		"CopyWithAddPerm", "configDir/services/svc1", "/services/svc1", os.FileMode(0000),
	).Return(nil)

	err := manager.RemoveAndDeployStacks(mockConfig, mockConfig, models.DeploymentParams{
		ServicesDir: "/services",
		WorkingDir:  "configDir",
	})
	assert.NoError(t, err)
}

func TestRemoveAndDeployStacks_Errors(t *testing.T) {
	type ExpectedErrors struct {
		copyErr  error
		writeErr error
		runErr   error
	}
	testCases := []struct {
		name          string
		errors        ExpectedErrors
		expectedError error
	}{
		{
			name:          "run error",
			errors:        ExpectedErrors{runErr: ErrRunCmd},
			expectedError: ErrRunCmd,
		},

		{
			name:          "copyServices error",
			errors:        ExpectedErrors{copyErr: ErrCopy},
			expectedError: ErrCopy,
		},

		{
			name:          "write to file error",
			errors:        ExpectedErrors{writeErr: ErrWriteFile},
			expectedError: ErrWriteFile,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			mocker := &Mocker{}
			manager := newManagerWithMocks(mocker)
			mock.InOrder(
				mocker.On("WriteToFile", mock.Anything, mock.Anything).Return(tc.errors.writeErr),
				mocker.On(
					"Run", "docker", []string{"compose", "--project-directory", filepath.Join("/", "services", "svc1"), "up", "-d"},
				).Return(tc.errors.runErr),
			)

			mocker.On(
				"CopyWithAddPerm", "configDir/services/svc1", "/services/svc1", os.FileMode(0000),
			).Return(tc.errors.copyErr)

			mocker.On(
				"CopyWithAddPerm", "configDir/services/svc3", "/services/svc3", os.FileMode(0000),
			).Return(tc.errors.copyErr)
			err := manager.RemoveAndDeployStacks(mockConfig, mockConfig, models.DeploymentParams{
				ServicesDir: "/services",
				WorkingDir:  "configDir",
			})

			assert.ErrorContains(t, err, fmt.Sprint(tc.expectedError))
		})
	}
}
